/*
 * generated by Xtext
 */
package gov.ca.dwr.wresl.xtext.editor.serializer;

import com.google.inject.Inject;
import gov.ca.dwr.wresl.xtext.editor.services.WreslEditorGrammarAccess;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.AbsFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.AcosFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.AcotFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Add;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Alias;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.AsinFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Assignment;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.AtanFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.CaseContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Condition;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ConditionalTerm;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ConstDef;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Constraint;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.CosFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.CotFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.DVarIntegerStd;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.DVarNonStd;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.DVarStd;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Declaration;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.DvarDef;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ElseIfTerm;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ElseTerm;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.External;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ExternalDef;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ExternalFunction1;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ExternalFunction2;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Goal;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.GoalCase;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.GoalCaseContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.GoalNoCaseContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.GoalSimple;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Group;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Ident;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.IfTerm;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.IncludeFile;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Initial;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.IntFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.LhsGtRhs;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.LhsLtRhs;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.LogFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.LogicalExpression;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Lower;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.MaxFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.MinFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ModFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Model;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Multiply;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Objective;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Penalty;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.PowFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.RoundFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SVarCase;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SVarDSS;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SVarExpression;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SVarSum;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SVarTable;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Sequence;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SinFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SubContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SumContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SumHeader;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.SvarDef;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.TableContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.TanFunction;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Term;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.TimeArraySize;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.TrunkTimeArray;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.TrunkTimeArrayIndex;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.Upper;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.ValueContent;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.VarModel;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.VarModelIndex;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.VarModelIndexStep;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.VarModelStep;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.WeightItem;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.WhereItems;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.WreslEditorPackage;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.WreslEvaluator;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.lowerUpper;
import gov.ca.dwr.wresl.xtext.editor.wreslEditor.upperLower;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public abstract class AbstractWreslEditorSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private WreslEditorGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == WreslEditorPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case WreslEditorPackage.ABS_FUNCTION:
				sequence_AbsFunction(context, (AbsFunction) semanticObject); 
				return; 
			case WreslEditorPackage.ACOS_FUNCTION:
				sequence_AcosFunction(context, (AcosFunction) semanticObject); 
				return; 
			case WreslEditorPackage.ACOT_FUNCTION:
				sequence_AcotFunction(context, (AcotFunction) semanticObject); 
				return; 
			case WreslEditorPackage.ADD:
				sequence_Add(context, (Add) semanticObject); 
				return; 
			case WreslEditorPackage.ALIAS:
				sequence_Alias(context, (Alias) semanticObject); 
				return; 
			case WreslEditorPackage.ASIN_FUNCTION:
				sequence_AsinFunction(context, (AsinFunction) semanticObject); 
				return; 
			case WreslEditorPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case WreslEditorPackage.ATAN_FUNCTION:
				sequence_AtanFunction(context, (AtanFunction) semanticObject); 
				return; 
			case WreslEditorPackage.CASE_CONTENT:
				sequence_CaseContent(context, (CaseContent) semanticObject); 
				return; 
			case WreslEditorPackage.CONDITION:
				sequence_Condition(context, (Condition) semanticObject); 
				return; 
			case WreslEditorPackage.CONDITIONAL_TERM:
				sequence_ConditionalTerm(context, (ConditionalTerm) semanticObject); 
				return; 
			case WreslEditorPackage.CONST_DEF:
				sequence_ConstDef(context, (ConstDef) semanticObject); 
				return; 
			case WreslEditorPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case WreslEditorPackage.COS_FUNCTION:
				sequence_CosFunction(context, (CosFunction) semanticObject); 
				return; 
			case WreslEditorPackage.COT_FUNCTION:
				sequence_CotFunction(context, (CotFunction) semanticObject); 
				return; 
			case WreslEditorPackage.DVAR_INTEGER_STD:
				sequence_DVarIntegerStd(context, (DVarIntegerStd) semanticObject); 
				return; 
			case WreslEditorPackage.DVAR_NON_STD:
				sequence_DVarNonStd(context, (DVarNonStd) semanticObject); 
				return; 
			case WreslEditorPackage.DVAR_STD:
				sequence_DVarStd(context, (DVarStd) semanticObject); 
				return; 
			case WreslEditorPackage.DECLARATION:
				sequence_Declaration(context, (Declaration) semanticObject); 
				return; 
			case WreslEditorPackage.DVAR_DEF:
				sequence_DvarDef(context, (DvarDef) semanticObject); 
				return; 
			case WreslEditorPackage.ELSE_IF_TERM:
				sequence_ElseIfTerm(context, (ElseIfTerm) semanticObject); 
				return; 
			case WreslEditorPackage.ELSE_TERM:
				sequence_ElseTerm(context, (ElseTerm) semanticObject); 
				return; 
			case WreslEditorPackage.EXTERNAL:
				sequence_External(context, (External) semanticObject); 
				return; 
			case WreslEditorPackage.EXTERNAL_DEF:
				sequence_ExternalDef(context, (ExternalDef) semanticObject); 
				return; 
			case WreslEditorPackage.EXTERNAL_FUNCTION1:
				sequence_ExternalFunction1(context, (ExternalFunction1) semanticObject); 
				return; 
			case WreslEditorPackage.EXTERNAL_FUNCTION2:
				sequence_ExternalFunction2(context, (ExternalFunction2) semanticObject); 
				return; 
			case WreslEditorPackage.GOAL:
				sequence_Goal(context, (Goal) semanticObject); 
				return; 
			case WreslEditorPackage.GOAL_CASE:
				sequence_GoalCase(context, (GoalCase) semanticObject); 
				return; 
			case WreslEditorPackage.GOAL_CASE_CONTENT:
				sequence_GoalCaseContent(context, (GoalCaseContent) semanticObject); 
				return; 
			case WreslEditorPackage.GOAL_NO_CASE_CONTENT:
				sequence_GoalNoCaseContent(context, (GoalNoCaseContent) semanticObject); 
				return; 
			case WreslEditorPackage.GOAL_SIMPLE:
				sequence_GoalSimple(context, (GoalSimple) semanticObject); 
				return; 
			case WreslEditorPackage.GROUP:
				sequence_Group(context, (Group) semanticObject); 
				return; 
			case WreslEditorPackage.IDENT:
				sequence_Ident(context, (Ident) semanticObject); 
				return; 
			case WreslEditorPackage.IF_TERM:
				if (rule == grammarAccess.getIfIncItemsRule()) {
					sequence_IfIncItems_IfTerm(context, (IfTerm) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getIfTermRule()) {
					sequence_IfTerm(context, (IfTerm) semanticObject); 
					return; 
				}
				else break;
			case WreslEditorPackage.INCLUDE_FILE:
				sequence_IncludeFile(context, (IncludeFile) semanticObject); 
				return; 
			case WreslEditorPackage.INITIAL:
				sequence_Initial(context, (Initial) semanticObject); 
				return; 
			case WreslEditorPackage.INT_FUNCTION:
				sequence_IntFunction(context, (IntFunction) semanticObject); 
				return; 
			case WreslEditorPackage.LHS_GT_RHS:
				sequence_LhsGtRhs(context, (LhsGtRhs) semanticObject); 
				return; 
			case WreslEditorPackage.LHS_LT_RHS:
				sequence_LhsLtRhs(context, (LhsLtRhs) semanticObject); 
				return; 
			case WreslEditorPackage.LOG_FUNCTION:
				sequence_LogFunction(context, (LogFunction) semanticObject); 
				return; 
			case WreslEditorPackage.LOGICAL_EXPRESSION:
				sequence_LogicalExpression(context, (LogicalExpression) semanticObject); 
				return; 
			case WreslEditorPackage.LOWER:
				sequence_Lower(context, (Lower) semanticObject); 
				return; 
			case WreslEditorPackage.MAX_FUNCTION:
				sequence_MaxFunction(context, (MaxFunction) semanticObject); 
				return; 
			case WreslEditorPackage.MIN_FUNCTION:
				sequence_MinFunction(context, (MinFunction) semanticObject); 
				return; 
			case WreslEditorPackage.MOD_FUNCTION:
				sequence_ModFunction(context, (ModFunction) semanticObject); 
				return; 
			case WreslEditorPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case WreslEditorPackage.MULTIPLY:
				sequence_Multiply(context, (Multiply) semanticObject); 
				return; 
			case WreslEditorPackage.OBJECTIVE:
				sequence_Objective(context, (Objective) semanticObject); 
				return; 
			case WreslEditorPackage.PENALTY:
				sequence_Penalty(context, (Penalty) semanticObject); 
				return; 
			case WreslEditorPackage.POW_FUNCTION:
				sequence_PowFunction(context, (PowFunction) semanticObject); 
				return; 
			case WreslEditorPackage.ROUND_FUNCTION:
				sequence_RoundFunction(context, (RoundFunction) semanticObject); 
				return; 
			case WreslEditorPackage.SVAR_CASE:
				sequence_SVarCase(context, (SVarCase) semanticObject); 
				return; 
			case WreslEditorPackage.SVAR_DSS:
				sequence_SVarDSS(context, (SVarDSS) semanticObject); 
				return; 
			case WreslEditorPackage.SVAR_EXPRESSION:
				sequence_SVarExpression(context, (SVarExpression) semanticObject); 
				return; 
			case WreslEditorPackage.SVAR_SUM:
				sequence_SVarSum(context, (SVarSum) semanticObject); 
				return; 
			case WreslEditorPackage.SVAR_TABLE:
				sequence_SVarTable(context, (SVarTable) semanticObject); 
				return; 
			case WreslEditorPackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case WreslEditorPackage.SIN_FUNCTION:
				sequence_SinFunction(context, (SinFunction) semanticObject); 
				return; 
			case WreslEditorPackage.SUB_CONTENT:
				sequence_SubContent(context, (SubContent) semanticObject); 
				return; 
			case WreslEditorPackage.SUM_CONTENT:
				sequence_SumContent(context, (SumContent) semanticObject); 
				return; 
			case WreslEditorPackage.SUM_HEADER:
				sequence_SumHeader(context, (SumHeader) semanticObject); 
				return; 
			case WreslEditorPackage.SVAR_DEF:
				sequence_SvarDef(context, (SvarDef) semanticObject); 
				return; 
			case WreslEditorPackage.TABLE_CONTENT:
				sequence_TableContent(context, (TableContent) semanticObject); 
				return; 
			case WreslEditorPackage.TAN_FUNCTION:
				sequence_TanFunction(context, (TanFunction) semanticObject); 
				return; 
			case WreslEditorPackage.TERM:
				sequence_Term(context, (Term) semanticObject); 
				return; 
			case WreslEditorPackage.TIME_ARRAY_SIZE:
				sequence_TimeArraySize(context, (TimeArraySize) semanticObject); 
				return; 
			case WreslEditorPackage.TRUNK_TIME_ARRAY:
				sequence_TrunkTimeArray(context, (TrunkTimeArray) semanticObject); 
				return; 
			case WreslEditorPackage.TRUNK_TIME_ARRAY_INDEX:
				sequence_TrunkTimeArrayIndex(context, (TrunkTimeArrayIndex) semanticObject); 
				return; 
			case WreslEditorPackage.UPPER:
				sequence_Upper(context, (Upper) semanticObject); 
				return; 
			case WreslEditorPackage.VALUE_CONTENT:
				sequence_ValueContent(context, (ValueContent) semanticObject); 
				return; 
			case WreslEditorPackage.VAR_MODEL:
				sequence_VarModel(context, (VarModel) semanticObject); 
				return; 
			case WreslEditorPackage.VAR_MODEL_INDEX:
				sequence_VarModelIndex(context, (VarModelIndex) semanticObject); 
				return; 
			case WreslEditorPackage.VAR_MODEL_INDEX_STEP:
				sequence_VarModelIndexStep(context, (VarModelIndexStep) semanticObject); 
				return; 
			case WreslEditorPackage.VAR_MODEL_STEP:
				sequence_VarModelStep(context, (VarModelStep) semanticObject); 
				return; 
			case WreslEditorPackage.WEIGHT_ITEM:
				sequence_WeightItem(context, (WeightItem) semanticObject); 
				return; 
			case WreslEditorPackage.WHERE_ITEMS:
				sequence_WhereItems(context, (WhereItems) semanticObject); 
				return; 
			case WreslEditorPackage.WRESL_EVALUATOR:
				sequence_WreslEvaluator(context, (WreslEvaluator) semanticObject); 
				return; 
			case WreslEditorPackage.LOWER_UPPER:
				if (rule == grammarAccess.getDVarIntegerRule()
						|| rule == grammarAccess.getDVarIntegerNonStdRule()) {
					sequence_DVarIntegerNonStd_lowerUpper(context, (lowerUpper) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLowerAndOrUpperRule()
						|| rule == grammarAccess.getLowerUpperRule()) {
					sequence_lowerUpper(context, (lowerUpper) semanticObject); 
					return; 
				}
				else break;
			case WreslEditorPackage.UPPER_LOWER:
				if (rule == grammarAccess.getDVarIntegerRule()
						|| rule == grammarAccess.getDVarIntegerNonStdRule()) {
					sequence_DVarIntegerNonStd_upperLower(context, (upperLower) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getLowerAndOrUpperRule()
						|| rule == grammarAccess.getUpperLowerRule()) {
					sequence_upperLower(context, (upperLower) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     TermSimple returns AbsFunction
	 *     Function returns AbsFunction
	 *     AbsFunction returns AbsFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_AbsFunction(ISerializationContext context, AbsFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ABS_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ABS_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns AcosFunction
	 *     Function returns AcosFunction
	 *     AcosFunction returns AcosFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_AcosFunction(ISerializationContext context, AcosFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ACOS_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ACOS_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAcosFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns AcotFunction
	 *     Function returns AcotFunction
	 *     AcotFunction returns AcotFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_AcotFunction(ISerializationContext context, AcotFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ACOT_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ACOT_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAcotFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Add
	 *     Add returns Add
	 *
	 * Constraint:
	 *     (m1=Multiply m2+=Multiply*)
	 */
	protected void sequence_Add(ISerializationContext context, Add semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Alias
	 *     Variable returns Alias
	 *     DecisionVariable returns Alias
	 *     Alias returns Alias
	 *
	 * Constraint:
	 *     (
	 *         ta=TimeArraySize? 
	 *         (local?='local' | local?='LOCAL')? 
	 *         ref=[Declaration|ID] 
	 *         expression=Expression 
	 *         kind=STRING? 
	 *         units=STRING?
	 *     )
	 */
	protected void sequence_Alias(ISerializationContext context, Alias semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns AsinFunction
	 *     Function returns AsinFunction
	 *     AsinFunction returns AsinFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_AsinFunction(ISerializationContext context, AsinFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ASIN_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ASIN_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAsinFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (term=TermSimple expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ASSIGNMENT__TERM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ASSIGNMENT__TERM));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getTermTermSimpleParserRuleCall_0_0(), semanticObject.getTerm());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns AtanFunction
	 *     Function returns AtanFunction
	 *     AtanFunction returns AtanFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_AtanFunction(ISerializationContext context, AtanFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ATAN_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ATAN_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtanFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CaseContent returns CaseContent
	 *
	 * Constraint:
	 *     ((caseName=ID | caseName=SpecialIdent) condition=Condition (content=TableContent | content=ValueContent | content=SumContent))
	 */
	protected void sequence_CaseContent(ISerializationContext context, CaseContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Condition returns Condition
	 *
	 * Constraint:
	 *     logical=LogicalExpression?
	 */
	protected void sequence_Condition(ISerializationContext context, Condition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionalUnary returns ConditionalTerm
	 *     ConditionalTerm returns ConditionalTerm
	 *
	 * Constraint:
	 *     (e1=Expression e2=Expression)
	 */
	protected void sequence_ConditionalTerm(ISerializationContext context, ConditionalTerm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.CONDITIONAL_TERM__E1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.CONDITIONAL_TERM__E1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.CONDITIONAL_TERM__E2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.CONDITIONAL_TERM__E2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConditionalTermAccess().getE1ExpressionParserRuleCall_0_0_0(), semanticObject.getE1());
		feeder.accept(grammarAccess.getConditionalTermAccess().getE2ExpressionParserRuleCall_0_2_0(), semanticObject.getE2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns ConstDef
	 *     Variable returns ConstDef
	 *     StateVariable returns ConstDef
	 *     ConstDef returns ConstDef
	 *
	 * Constraint:
	 *     ((local?='local' | local?='LOCAL')? ref=[Declaration|ID] definition=Number)
	 */
	protected void sequence_ConstDef(ISerializationContext context, ConstDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (lhs=Expression (operator='<' | operator='>' | operator='=') rhs=Expression)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns CosFunction
	 *     Function returns CosFunction
	 *     CosFunction returns CosFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_CosFunction(ISerializationContext context, CosFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.COS_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.COS_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCosFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns CotFunction
	 *     Function returns CotFunction
	 *     CotFunction returns CotFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_CotFunction(ISerializationContext context, CotFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.COT_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.COT_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCotFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DVarInteger returns lowerUpper
	 *     DVarIntegerNonStd returns lowerUpper
	 *
	 * Constraint:
	 *     (lower=Lower upper=Upper? kind=STRING units=STRING)
	 */
	protected void sequence_DVarIntegerNonStd_lowerUpper(ISerializationContext context, lowerUpper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DVarInteger returns upperLower
	 *     DVarIntegerNonStd returns upperLower
	 *
	 * Constraint:
	 *     (upper=Upper lower=Lower? kind=STRING units=STRING)
	 */
	protected void sequence_DVarIntegerNonStd_upperLower(ISerializationContext context, upperLower semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DVarInteger returns DVarIntegerStd
	 *     DVarIntegerStd returns DVarIntegerStd
	 *
	 * Constraint:
	 *     (kind=STRING units=STRING)
	 */
	protected void sequence_DVarIntegerStd(ISerializationContext context, DVarIntegerStd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR_INTEGER_STD__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR_INTEGER_STD__KIND));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR_INTEGER_STD__UNITS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR_INTEGER_STD__UNITS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDVarIntegerStdAccess().getKindSTRINGTerminalRuleCall_3_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getDVarIntegerStdAccess().getUnitsSTRINGTerminalRuleCall_5_0(), semanticObject.getUnits());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DVar returns DVarNonStd
	 *     DVarNonStd returns DVarNonStd
	 *
	 * Constraint:
	 *     (lowerUpper=LowerAndOrUpper kind=STRING units=STRING)
	 */
	protected void sequence_DVarNonStd(ISerializationContext context, DVarNonStd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR_NON_STD__LOWER_UPPER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR_NON_STD__LOWER_UPPER));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR__KIND));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR__UNITS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR__UNITS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDVarNonStdAccess().getLowerUpperLowerAndOrUpperParserRuleCall_0_0(), semanticObject.getLowerUpper());
		feeder.accept(grammarAccess.getDVarNonStdAccess().getKindSTRINGTerminalRuleCall_2_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getDVarNonStdAccess().getUnitsSTRINGTerminalRuleCall_4_0(), semanticObject.getUnits());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DVar returns DVarStd
	 *     DVarStd returns DVarStd
	 *
	 * Constraint:
	 *     (kind=STRING units=STRING)
	 */
	protected void sequence_DVarStd(ISerializationContext context, DVarStd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR__KIND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR__KIND));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DVAR__UNITS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DVAR__UNITS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDVarStdAccess().getKindSTRINGTerminalRuleCall_2_0(), semanticObject.getKind());
		feeder.accept(grammarAccess.getDVarStdAccess().getUnitsSTRINGTerminalRuleCall_4_0(), semanticObject.getUnits());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WreslEvaluator returns Declaration
	 *     Declaration returns Declaration
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Declaration(ISerializationContext context, Declaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.DECLARATION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns DvarDef
	 *     Variable returns DvarDef
	 *     DecisionVariable returns DvarDef
	 *     DvarDef returns DvarDef
	 *
	 * Constraint:
	 *     (
	 *         (ta=TimeArraySize? (local?='local' | local?='LOCAL')? ref=[Declaration|ID] (definition=DVar | definition=DVarInteger)) | 
	 *         (ta=TimeArraySize? (local?='local' | local?='LOCAL')? ref=[Declaration|ID] (definition=DVar | definition=DVarInteger))
	 *     )
	 */
	protected void sequence_DvarDef(ISerializationContext context, DvarDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseIfTerm returns ElseIfTerm
	 *
	 * Constraint:
	 *     (logical+=LogicalExpression pattern+=Pattern+)+
	 */
	protected void sequence_ElseIfTerm(ISerializationContext context, ElseIfTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElseTerm returns ElseTerm
	 *
	 * Constraint:
	 *     pattern+=Pattern+
	 */
	protected void sequence_ElseTerm(ISerializationContext context, ElseTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns ExternalDef
	 *     Variable returns ExternalDef
	 *     ExternalDef returns ExternalDef
	 *
	 * Constraint:
	 *     ((local?='local' | local?='LOCAL')? ref=[Declaration|ID] definition=External)
	 */
	protected void sequence_ExternalDef(ISerializationContext context, ExternalDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns ExternalFunction1
	 *     Function returns ExternalFunction1
	 *     ExternalFunction1 returns ExternalFunction1
	 *
	 * Constraint:
	 *     (ref=[Declaration|ID]? (e1=Expression | e1=TrunkTimeArray) e2+=Expression? (e2+=TrunkTimeArray? e2+=Expression?)* e0=Expression?)
	 */
	protected void sequence_ExternalFunction1(ISerializationContext context, ExternalFunction1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns ExternalFunction2
	 *     Function returns ExternalFunction2
	 *     ExternalFunction2 returns ExternalFunction2
	 *
	 * Constraint:
	 *     ref=[Declaration|ID]
	 */
	protected void sequence_ExternalFunction2(ISerializationContext context, ExternalFunction2 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.EXTERNAL_FUNCTION2__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.EXTERNAL_FUNCTION2__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExternalFunction2Access().getRefDeclarationIDTerminalRuleCall_0_0_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     External returns External
	 *
	 * Constraint:
	 *     (name=ID | name=ID)
	 */
	protected void sequence_External(ISerializationContext context, External semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GoalCaseContent returns GoalCaseContent
	 *
	 * Constraint:
	 *     ((caseName=ID | caseName=SpecialIdent) condition=Condition rhs=Expression subContent=SubContent?)
	 */
	protected void sequence_GoalCaseContent(ISerializationContext context, GoalCaseContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GoalCase returns GoalCase
	 *
	 * Constraint:
	 *     (lhs=Expression (content=GoalNoCaseContent | caseContent+=GoalCaseContent+))
	 */
	protected void sequence_GoalCase(ISerializationContext context, GoalCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GoalNoCaseContent returns GoalNoCaseContent
	 *
	 * Constraint:
	 *     (rhs=Expression subContent=SubContent?)
	 */
	protected void sequence_GoalNoCaseContent(ISerializationContext context, GoalNoCaseContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GoalSimple returns GoalSimple
	 *
	 * Constraint:
	 *     constraint=Constraint
	 */
	protected void sequence_GoalSimple(ISerializationContext context, GoalSimple semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.GOAL_SIMPLE__CONSTRAINT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.GOAL_SIMPLE__CONSTRAINT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGoalSimpleAccess().getConstraintConstraintParserRuleCall_0(), semanticObject.getConstraint());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Goal
	 *     Goal returns Goal
	 *
	 * Constraint:
	 *     (ta=TimeArraySize? (local?='local' | local?='LOCAL')? name=ID (definition=GoalSimple | definition=GoalCase))
	 */
	protected void sequence_Goal(ISerializationContext context, Goal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Group returns Group
	 *
	 * Constraint:
	 *     (name=ID (pattern+=Pattern | ifincitems+=IfIncItems)+)
	 */
	protected void sequence_Group(ISerializationContext context, Group semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ident returns Ident
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Ident(ISerializationContext context, Ident semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.IDENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.IDENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     IfIncItems returns IfTerm
	 *
	 * Constraint:
	 *     (logical=LogicalExpression pattern+=Pattern+ elseifterm=ElseIfTerm? elseterm=ElseTerm?)
	 */
	protected void sequence_IfIncItems_IfTerm(ISerializationContext context, IfTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IfTerm returns IfTerm
	 *
	 * Constraint:
	 *     (logical=LogicalExpression pattern+=Pattern+)
	 */
	protected void sequence_IfTerm(ISerializationContext context, IfTerm semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns IncludeFile
	 *     IncludeFile returns IncludeFile
	 *
	 * Constraint:
	 *     ((local?='local' | local?='LOCAL')? file=STRING)
	 */
	protected void sequence_IncludeFile(ISerializationContext context, IncludeFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Initial returns Initial
	 *
	 * Constraint:
	 *     pattern+=Pattern+
	 */
	protected void sequence_Initial(ISerializationContext context, Initial semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns IntFunction
	 *     Function returns IntFunction
	 *     IntFunction returns IntFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_IntFunction(ISerializationContext context, IntFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.INT_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.INT_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LhsGtRhs returns LhsGtRhs
	 *
	 * Constraint:
	 *     penalty=Penalty?
	 */
	protected void sequence_LhsGtRhs(ISerializationContext context, LhsGtRhs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LhsLtRhs returns LhsLtRhs
	 *
	 * Constraint:
	 *     penalty=Penalty?
	 */
	protected void sequence_LhsLtRhs(ISerializationContext context, LhsLtRhs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns LogFunction
	 *     Function returns LogFunction
	 *     LogFunction returns LogFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_LogFunction(ISerializationContext context, LogFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.LOG_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.LOG_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LogicalExpression returns LogicalExpression
	 *     ConditionalUnary returns LogicalExpression
	 *     ConditionalTerm returns LogicalExpression
	 *
	 * Constraint:
	 *     (c1=ConditionalUnary c2+=ConditionalUnary*)
	 */
	protected void sequence_LogicalExpression(ISerializationContext context, LogicalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Lower returns Lower
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_Lower(ISerializationContext context, Lower semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns MaxFunction
	 *     Function returns MaxFunction
	 *     MaxFunction returns MaxFunction
	 *
	 * Constraint:
	 *     (e1=Expression e2+=Expression*)
	 */
	protected void sequence_MaxFunction(ISerializationContext context, MaxFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns MinFunction
	 *     Function returns MinFunction
	 *     MinFunction returns MinFunction
	 *
	 * Constraint:
	 *     (e1=Expression e2+=Expression*)
	 */
	protected void sequence_MinFunction(ISerializationContext context, MinFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns ModFunction
	 *     Function returns ModFunction
	 *     ModFunction returns ModFunction
	 *
	 * Constraint:
	 *     (e1=Expression e2=Expression)
	 */
	protected void sequence_ModFunction(ISerializationContext context, ModFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.MOD_FUNCTION__E1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.MOD_FUNCTION__E1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.MOD_FUNCTION__E2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.MOD_FUNCTION__E2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModFunctionAccess().getE1ExpressionParserRuleCall_2_0(), semanticObject.getE1());
		feeder.accept(grammarAccess.getModFunctionAccess().getE2ExpressionParserRuleCall_4_0(), semanticObject.getE2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID (pattern+=Pattern | ifincitems+=IfIncItems)+)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Multiply returns Multiply
	 *
	 * Constraint:
	 *     (u1=Unary u2+=Unary*)
	 */
	protected void sequence_Multiply(ISerializationContext context, Multiply semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Objective
	 *     Objective returns Objective
	 *
	 * Constraint:
	 *     ((local?='local' | local?='LOCAL')? name=ID weights+=WeightItem+)
	 */
	protected void sequence_Objective(ISerializationContext context, Objective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Penalty returns Penalty
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_Penalty(ISerializationContext context, Penalty semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.PENALTY__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.PENALTY__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPenaltyAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns PowFunction
	 *     Function returns PowFunction
	 *     PowFunction returns PowFunction
	 *
	 * Constraint:
	 *     (e1=Expression e2=Expression)
	 */
	protected void sequence_PowFunction(ISerializationContext context, PowFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.POW_FUNCTION__E1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.POW_FUNCTION__E1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.POW_FUNCTION__E2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.POW_FUNCTION__E2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPowFunctionAccess().getE1ExpressionParserRuleCall_2_0(), semanticObject.getE1());
		feeder.accept(grammarAccess.getPowFunctionAccess().getE2ExpressionParserRuleCall_4_0(), semanticObject.getE2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns RoundFunction
	 *     Function returns RoundFunction
	 *     RoundFunction returns RoundFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_RoundFunction(ISerializationContext context, RoundFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.ROUND_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.ROUND_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRoundFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SVar returns SVarCase
	 *     SVarCase returns SVarCase
	 *
	 * Constraint:
	 *     caseContent+=CaseContent+
	 */
	protected void sequence_SVarCase(ISerializationContext context, SVarCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SVar returns SVarDSS
	 *     SVarDSS returns SVarDSS
	 *
	 * Constraint:
	 *     (bPart=STRING? kind=STRING units=STRING convert=STRING?)
	 */
	protected void sequence_SVarDSS(ISerializationContext context, SVarDSS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SVar returns SVarExpression
	 *     SVarExpression returns SVarExpression
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_SVarExpression(ISerializationContext context, SVarExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SVAR_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SVAR_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSVarExpressionAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SVar returns SVarSum
	 *     SVarSum returns SVarSum
	 *
	 * Constraint:
	 *     sumContent=SumContent
	 */
	protected void sequence_SVarSum(ISerializationContext context, SVarSum semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SVAR_SUM__SUM_CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SVAR_SUM__SUM_CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSVarSumAccess().getSumContentSumContentParserRuleCall_0(), semanticObject.getSumContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SVar returns SVarTable
	 *     SVarTable returns SVarTable
	 *
	 * Constraint:
	 *     tableContent=TableContent
	 */
	protected void sequence_SVarTable(ISerializationContext context, SVarTable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SVAR_TABLE__TABLE_CONTENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SVAR_TABLE__TABLE_CONTENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSVarTableAccess().getTableContentTableContentParserRuleCall_0(), semanticObject.getTableContent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sequence returns Sequence
	 *
	 * Constraint:
	 *     ((name=ID model=[Model|ID] condition=Condition? order=INT?) | (order=INT condition=Condition) | condition=Condition)?
	 */
	protected void sequence_Sequence(ISerializationContext context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns SinFunction
	 *     Function returns SinFunction
	 *     SinFunction returns SinFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_SinFunction(ISerializationContext context, SinFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SIN_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SIN_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSinFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SubContent returns SubContent
	 *
	 * Constraint:
	 *     ((gt=LhsGtRhs lt=LhsLtRhs?) | (lt=LhsLtRhs gt=LhsGtRhs?))
	 */
	protected void sequence_SubContent(ISerializationContext context, SubContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SumContent returns SumContent
	 *     TermSimple returns SumContent
	 *     Function returns SumContent
	 *
	 * Constraint:
	 *     (header=SumHeader expression=Expression)
	 */
	protected void sequence_SumContent(ISerializationContext context, SumContent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SUM_CONTENT__HEADER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SUM_CONTENT__HEADER));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SUM_CONTENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SUM_CONTENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumContentAccess().getHeaderSumHeaderParserRuleCall_1_0(), semanticObject.getHeader());
		feeder.accept(grammarAccess.getSumContentAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SumHeader returns SumHeader
	 *
	 * Constraint:
	 *     (expression1=Expression expression2=Expression)
	 */
	protected void sequence_SumHeader(ISerializationContext context, SumHeader semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SUM_HEADER__EXPRESSION1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SUM_HEADER__EXPRESSION1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.SUM_HEADER__EXPRESSION2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.SUM_HEADER__EXPRESSION2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSumHeaderAccess().getExpression1ExpressionParserRuleCall_2_0(), semanticObject.getExpression1());
		feeder.accept(grammarAccess.getSumHeaderAccess().getExpression2ExpressionParserRuleCall_4_0(), semanticObject.getExpression2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns SvarDef
	 *     Variable returns SvarDef
	 *     StateVariable returns SvarDef
	 *     SvarDef returns SvarDef
	 *
	 * Constraint:
	 *     (
	 *         (ta=TimeArraySize? (local?='local' | local?='LOCAL')? ref=[Declaration|ID] definition=SVar) | 
	 *         (ta=TimeArraySize? (local?='local' | local?='LOCAL')? ref=[Declaration|ID] definition=SVar)
	 *     )
	 */
	protected void sequence_SvarDef(ISerializationContext context, SvarDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TableContent returns TableContent
	 *
	 * Constraint:
	 *     ((tableName=ID | tableName=SpecialIdent) (from=ID | from=SpecialIdent) (given=Assignment use=ID)? where=WhereItems?)
	 */
	protected void sequence_TableContent(ISerializationContext context, TableContent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns TanFunction
	 *     Function returns TanFunction
	 *     TanFunction returns TanFunction
	 *
	 * Constraint:
	 *     e=Expression
	 */
	protected void sequence_TanFunction(ISerializationContext context, TanFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.TAN_FUNCTION__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.TAN_FUNCTION__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTanFunctionAccess().getEExpressionParserRuleCall_2_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Unary returns Term
	 *     Term returns Term
	 *
	 * Constraint:
	 *     (ref=[Declaration|ID] | n=Number | f=Function | e=Expression | s=SpecialIdent)
	 */
	protected void sequence_Term(ISerializationContext context, Term semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TimeArraySize returns TimeArraySize
	 *
	 * Constraint:
	 *     name=[Declaration|ID]
	 */
	protected void sequence_TimeArraySize(ISerializationContext context, TimeArraySize semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.TIME_ARRAY_SIZE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.TIME_ARRAY_SIZE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeArraySizeAccess().getNameDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TrunkTimeArrayIndex returns TrunkTimeArrayIndex
	 *
	 * Constraint:
	 *     ref=[Declaration|ID]
	 */
	protected void sequence_TrunkTimeArrayIndex(ISerializationContext context, TrunkTimeArrayIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY_INDEX__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY_INDEX__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrunkTimeArrayIndexAccess().getRefDeclarationIDTerminalRuleCall_2_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TrunkTimeArray returns TrunkTimeArray
	 *
	 * Constraint:
	 *     (ref=[Declaration|ID] t1=TrunkTimeArrayIndex t2=TrunkTimeArrayIndex)
	 */
	protected void sequence_TrunkTimeArray(ISerializationContext context, TrunkTimeArray semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY__REF));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY__T1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY__T1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY__T2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.TRUNK_TIME_ARRAY__T2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrunkTimeArrayAccess().getRefDeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getRef());
		feeder.accept(grammarAccess.getTrunkTimeArrayAccess().getT1TrunkTimeArrayIndexParserRuleCall_2_0(), semanticObject.getT1());
		feeder.accept(grammarAccess.getTrunkTimeArrayAccess().getT2TrunkTimeArrayIndexParserRuleCall_4_0(), semanticObject.getT2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Upper returns Upper
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_Upper(ISerializationContext context, Upper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueContent returns ValueContent
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ValueContent(ISerializationContext context, ValueContent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VALUE_CONTENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VALUE_CONTENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getValueContentAccess().getExpressionExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns VarModelIndexStep
	 *     Function returns VarModelIndexStep
	 *     VarModelIndexStep returns VarModelIndexStep
	 *
	 * Constraint:
	 *     (ref1=[Declaration|ID] e=Expression)
	 */
	protected void sequence_VarModelIndexStep(ISerializationContext context, VarModelIndexStep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_INDEX_STEP__REF1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_INDEX_STEP__REF1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_INDEX_STEP__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_INDEX_STEP__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarModelIndexStepAccess().getRef1DeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getRef1());
		feeder.accept(grammarAccess.getVarModelIndexStepAccess().getEExpressionParserRuleCall_6_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns VarModelIndex
	 *     Function returns VarModelIndex
	 *     VarModelIndex returns VarModelIndex
	 *
	 * Constraint:
	 *     ref1=[Declaration|ID]
	 */
	protected void sequence_VarModelIndex(ISerializationContext context, VarModelIndex semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_INDEX__REF1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_INDEX__REF1));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarModelIndexAccess().getRef1DeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getRef1());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns VarModelStep
	 *     Function returns VarModelStep
	 *     VarModelStep returns VarModelStep
	 *
	 * Constraint:
	 *     (ref1=[Declaration|ID] ref2=[Model|ID] e=Expression)
	 */
	protected void sequence_VarModelStep(ISerializationContext context, VarModelStep semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_STEP__REF1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_STEP__REF1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_STEP__REF2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_STEP__REF2));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_STEP__E) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL_STEP__E));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarModelStepAccess().getRef1DeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getRef1());
		feeder.accept(grammarAccess.getVarModelStepAccess().getRef2ModelIDTerminalRuleCall_2_0_1(), semanticObject.getRef2());
		feeder.accept(grammarAccess.getVarModelStepAccess().getEExpressionParserRuleCall_5_0(), semanticObject.getE());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TermSimple returns VarModel
	 *     Function returns VarModel
	 *     VarModel returns VarModel
	 *
	 * Constraint:
	 *     (ref1=[Declaration|ID] ref2=[Model|ID])
	 */
	protected void sequence_VarModel(ISerializationContext context, VarModel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL__REF1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL__REF1));
			if (transientValues.isValueTransient(semanticObject, WreslEditorPackage.Literals.VAR_MODEL__REF2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, WreslEditorPackage.Literals.VAR_MODEL__REF2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarModelAccess().getRef1DeclarationIDTerminalRuleCall_0_0_1(), semanticObject.getRef1());
		feeder.accept(grammarAccess.getVarModelAccess().getRef2ModelIDTerminalRuleCall_2_0_1(), semanticObject.getRef2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WeightItem returns WeightItem
	 *
	 * Constraint:
	 *     (ref=[Declaration|ID] ta=TimeArraySize? expression=Expression)
	 */
	protected void sequence_WeightItem(ISerializationContext context, WeightItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WhereItems returns WhereItems
	 *
	 * Constraint:
	 *     (assignment+=Assignment assignment+=Assignment*)
	 */
	protected void sequence_WhereItems(ISerializationContext context, WhereItems semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WreslEvaluator returns WreslEvaluator
	 *
	 * Constraint:
	 *     ((pattern+=Pattern | ifincitem+=IfIncItems)+ | (initial=Initial? sequence+=Sequence+ (model+=Model | model+=Group)+))
	 */
	protected void sequence_WreslEvaluator(ISerializationContext context, WreslEvaluator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LowerAndOrUpper returns lowerUpper
	 *     lowerUpper returns lowerUpper
	 *
	 * Constraint:
	 *     (lower=Lower upper=Upper?)
	 */
	protected void sequence_lowerUpper(ISerializationContext context, lowerUpper semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LowerAndOrUpper returns upperLower
	 *     upperLower returns upperLower
	 *
	 * Constraint:
	 *     (upper=Upper lower=Lower?)
	 */
	protected void sequence_upperLower(ISerializationContext context, upperLower semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
